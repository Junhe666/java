总概括：
1.Java 基础知识点

2.Java 常见集合

3.高并发编程（JUC 包）

4.JVM 内存管理

5.Java 8 知识点

6.网络协议相关

7.数据库相关

8.MVC 框架相关

9.大数据相关

10.Linux 命令相关



##Java 基础知识

01. 面向对象的特性有哪些？

答：封装、继承和多态。

【面向对象编程的正确姿势】

02. Java 中覆盖和重载是什么意思？

解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。

答：覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小。

被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个方法；重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。

面试官： 那么构成重载的条件有哪些？

答：参数类型不同、参数个数不同、参数顺序不同。

面试官： 函数的返回值不同可以构成重载吗？为什么？

答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：

如下两个方法：

　　　　void f(){}　
　　　  int f(){ return 1;}

只要编译器可以根据语境明确判断出语义，比如在 int x = f();中，那么的确可以据此区分重载方法。

不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用”），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：

　　　　fun();

此时 Java 如何才能判断调用的是哪一个 f( ) 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。

03. 抽象类和接口的区别有哪些？

【Java 抽象类与接口】

答：

抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；

抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化 , 接口中只有常量，没有变量。

抽象类只能单继承，接口可以继承多个父接口；

Java8 中接口中会有 default 方法，即方法可以被实现。

面试官：抽象类和接口如何选择？

答：

如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。

如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。

因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。

04. Java 和 C++ 的区别：

解析：虽然我们不太懂 C++，但是就是会这么问，尤其是三面（总监级别）面试中。

答：

都是面向对象的语言，都支持封装、继承和多态；

指针：Java 不提供指针来直接访问内存，程序更加安全；

继承： Java 的类是单继承的，C++ 支持多重继承； Java 通过一个类实现多个接口来实现 C++ 中的多重继承； Java 中类不可以多继承，但是！！！接口可以多继承；

内存： Java 有自动内存管理机制，不需要程序员手动释放无用内存。

05. Java 中的值传递和引用传递

答：

值传递是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。引用传递是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。

因此，外部对引用对象的改变会反映到所有的对象上。

06. JDK 中常用的包有哪些？

答：java.lang、java.util、java.io、java.net、java.sql。

07. JDK，JRE 和 JVM 的联系和区别：

答：

JDK 是 java 开发工具包，是 java 开发环境的核心组件，并提供编译、调试和运行一个 java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。

JRE 是 java 运行时环境，是 JVM 的实施实现，提供了运行 java 程序的平台。JRE 包含了 JVM，但是不包含 java 编译器 / 调试器之类的开发工具。

JVM 是 java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。

【JVM 垃圾回收机制】

这种独立于硬件和操作系统，正是 java 程序可以一次编写多处执行的原因。

区别：

JDK 用于开发，JRE 用于运行 java 程序；

JDK 和 JRE 中都包含 JVM；

JVM 是 java 编程语言的核心并且具有平台独立性。

小结：本节主要阐述了 Java 基础知识点，这些问题主要是一面面试官在考察，难度不大，适当复习下，应该没什么问题。




##Java 中常见集合



集合这方面的考察相当多，这部分是面试中必考的知识点。

01. 说说常见的集合有哪些吧？

答：

Map 接口和 Collection 接口是所有集合框架的父接口：

1. Collection 接口的子接口包括：Set 接口和 List 接口；

2. Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；

3. Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；

4. List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。

02. HashMap 和 Hashtable 的区别有哪些？（必问）

答：

HashMap 没有考虑同步，是线程不安全的；Hashtable 使用了 synchronized 关键字，是线程安全的；

前者允许 null 作为 Key；后者不允许 null 作为 Key。

03. HashMap 的底层实现你知道吗？

答：

在 Java8 之前，其底层实现是数组 + 链表实现，Java8 使用了数组 + 链表 + 红黑树实现。此时你可以简单的在纸上画图分析：



04. ConcurrentHashMap 和 Hashtable 的区别？ （必问）

答：

ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。

HashMap 没有考虑同步，hashtable 考虑了同步的问题。但是 hashtable 在每次同步执行时都要锁住整个结构。

ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如 get,put,remove 等常用操作只锁当前需要用到的桶。

面试官：ConcurrentHashMap 的具体实现知道吗？

答：

该类包含两个静态内部类 HashEntry 和 Segment；前者用来封装映射表的键值对，后者用来充当锁的角色；

Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个 HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。

05. HashMap 的长度为什么是 2 的幂次方？

答：

通过将 Key 的 hash 值与 length-1 进行 & 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；

如果 length 为 2 的次幂  则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；

如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大。

更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。

06. List 和 Set 的区别是啥？

答：List 元素是有序的，可以重复；Set 元素是无序的，不可以重复。

07. List、Set 和 Map 的初始容量和加载因子

答：

1. List

ArrayList 的初始容量是 10；加载因子为 0.5； 扩容增量：原容量的 0.5 倍 +1；一次扩容后长度为 16。

Vector 初始容量为 10，加载因子是 1。扩容增量：原容量的 1 倍，如 Vector 的容量为 10，一次扩容后是容量为 20。

2. Set

HashSet，初始容量为 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashSet 的容量为 16，一次扩容后容量为 32

3. Map

HashMap，初始容量 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashMap 的容量为 16，一次扩容后容量为 32

08. Comparable 接口和 Comparator 接口有什么区别？

答：

前者简单，但是如果需要重新定义比较类型时，需要修改源代码。

后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。

09. Java 集合的快速失败机制 “fail-fast”

答：

它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。

例如 ：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。

原因： 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。

每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。

解决办法：

在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；

使用 CopyOnWriteArrayList 来替换 ArrayList。

小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。




##高并发编程

在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。

01. 多线程和单线程的区别和联系：

答：

在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。

多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。

结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。

02. 如何指定多个线程的执行顺序？

解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）

答：

设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。

在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。

03. 线程和进程的区别（必考）

答：

进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；

线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；

线程上下文的切换比进程上下文切换要快很多。

（1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。

（2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

04. 多线程产生死锁的 4 个必要条件？

答：

互斥条件：一个资源每次只能被一个线程使用；

请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；

不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；

循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

面试官：如何避免死锁？（经常接着问这个问题哦~）

答：指定获取锁的顺序，举例如下：

比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？

获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！

05. sleep( ) 和 wait( n)、wait( ) 的区别：

答：

sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；

wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。

06. synchronized 关键字：

答：

底层实现：

进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；

当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。

含义：（monitor 机制）

Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。

该关键字是一个几种锁的封装。

07. volatile 关键字

解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。

答：

该关键字可以保证可见性不保证原子性。

功能：

主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；

禁止 JVM 进行的指令重排序。

08. ThreadLocal（线程局部变量）关键字：

答：

当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。

ThreadLocal 内部实现机制：

每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；

Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；

Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。



09. Atomic 关键字：

答：可以使基本数据类型以原子的方式实现自增自减等操作。

10. 线程池有了解吗？（必考）

答：

java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：

当前线程池大小 ：表示线程池中实际工作者线程的数量；

最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；

核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。

如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；

如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；

如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。

限于篇幅有限，更多高并发编程中的问题，请参考：

1.  Java 多线程编程核心技术

2. Java多线程与并发编程

小结：本小节内容涉及到 Java 中多线程编程，线程安全等知识，是面试中的重点和难点。




JVM 内存管理



既然是 Java 开发面试，那么对 JVM 的考察当然也是必须的，面试官一般会问你对 JVM 有了解吗？

我通常都会把我所了解的都说一遍，包括：JVM 内存划分、JVM 垃圾回收的含义，有哪些 GC 算法，年轻代和老年代各自的特点统统阐述一遍。

【JVM 垃圾回收机制】

01. JVM 内存划分：

方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；

堆内存（线程共享）：垃圾回收的主要场所；

程序计数器： 当前线程执行的字节码的位置指示器；

虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；

本地方法栈 ：为 JVM 提供使用 native 方法的服务。

02. 类似-Xms、-Xmn 这些参数的含义：

答：

##堆内存分配：

JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；

JVM 最大分配的内存由-Xmx 指定，默认是物理内存的 1/4；

默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；

因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

非堆内存分配：

JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1/64；

由 XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的 1/4；

-Xmn2G：设置年轻代大小为 2G；

-XX:SurvivorRatio，设置年轻代中 Eden 区与 Survivor 区的比值。

03. 垃圾回收算法有哪些？

答：

引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题；

标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；

此算法需要暂停整个应用，同时，会产生内存碎片；

复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；

此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；

标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 到堆的其中一块，按顺序排放。

此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。

04. root 搜索算法中，哪些可以作为 root？

答：

被启动类（bootstrap 加载器）加载的类和创建的对象；

JavaStack 中的引用的对象 (栈内存中引用的对象)；

方法区中静态引用指向的对象；

方法区中常量引用指向的对象；

Native 方法中 JNI 引用的对象。

05. GC 什么时候开始？

答：

GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。

对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；

Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。

大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；

发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则改为进行一次 Full GC。

06. 内存泄漏和内存溢出

答：

概念：

内存溢出指的是内存不够用了；

内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；

内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。

内存泄漏的原因分析：

长生命周期的对象引用短生命周期的对象；

没有将无用对象置为 null。

小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。

比如：内存调优、内存管理，是否遇到过内存泄漏的实际案例、是否真正关心过内存等。由于本人实际项目经验不足，这些深层次问题并没有接触过，各位有需要可以上网查阅。




##Java 8 相关知识



关于 Java8 中新知识点，面试官会让你说说 Java8 你了解多少，下边主要阐述我所了解，并且在面试中回答的 Java8 新增知识点。

0.1 HashMap 的底层实现有变化：HashMap 是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分）实现。

02. JVM 内存管理方面，由元空间代替了永久代。

区别：

1. 元空间并不在虚拟机中，而是使用本地内存；

2. 默认情况下，元空间的大小仅受本地内存限制；

3. 也可以通过 -XX：MetaspaceSize 指定元空间大小。

03. Lambda 表达式（也称为闭包），允许我们将函数当成参数传递给某个方法，或者把代码本身当做数据处理。

04. 函数式接口：指的是只有一个函数的接口，java.lang.Runnable 和 java.util.concurrent.Callable 就是函数式接口的例子；java8 提供了一个特殊的注解 @Functionallnterface 来标明该接口是一个函数式接口。

05. 引入重复注解：Java 8 中使用 @Repeatable 注解定义重复注解。

06. 接口中可以实现方法 default 方法。

07. 注解的使用场景拓宽： 注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。

08. 新的包 java.time 包

包含了所有关于日期、时间、时区、持续时间和时钟操作的类。（Java 8 的日期与时间问题解决方案）

这些类都是不可变的、线程安全的。

小结：Java8 的一些新特性，面试官一般情况下不要求你有多么精通，主要是看看你有没有一些了解。




##网络协议相关



网络协议方面，考察最多的包括服务器和客户端在三次握手、四次挥手过程中的状态变化；还有网络拥塞控制，及其解决办法等。

01. 三次握手、四次挥手示意图：



总共有四种状态：主动建立连接、主动断开连接、被动建立连和被动断开连接

两两组合还是 4 种组合：

主动建立连接、主动断开连接会经历的状态：
SYNC_SENT——ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT

主动建立连接、被动断开连接会经历的状态：
SYNC_SENT——ESTABLISHED—-CLOSE_WAIT—-LAST_ACK

被动建立连接、主动断开连接会经历的状态：
LISTEN—-SYN_RCVD—-ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT

被动建立连接、被动断开连接会经历的状态：
LISTEN—-SYN_RCVD—-ESTABLISHED—-CLOSE_WAIT—-LAST_ACK

02. 滑动窗口机制

由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。

也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。

在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。

03. 拥塞避免机制

拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。

拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

拥塞控制方法：

慢开始 + 拥塞避免；

快重传 + 快恢复。





04. 浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。

解析：经典的网络协议问题。

答：

由域名→IP 地址
寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

建立 TCP/IP 连接（三次握手具体过程）

由浏览器发送一个 HTTP 请求

经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器

服务器处理该 HTTP 请求，返回一个 HTML 文件

浏览器解析该 HTML 文件，并且显示在浏览器端

这里需要注意：

HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接

可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。

两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

05. 常见 HTTP 状态码

1xx（临时响应）

2xx（成功）

3xx（重定向）：表示要完成请求需要进一步操作

4xx（错误）：表示请求可能出错，妨碍了服务器的处理

5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误

常见状态码：

200（成功）

304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容

401（未授权）：请求要求身份验证

403（禁止）：服务器拒绝请求

404（未找到）：服务器找不到请求的网页

06. TCP 和 UDP 的区别：

答：

回答发送数据前是否存在建立连接的过程；

ＴＣＰ过确认机制，丢包可以重发，保证数据的正确性；ＵＤＰ不保证正确性，只是单纯的负责发送数据包；

UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因 此，应用程序需要选择合适的报文大小；

UDP 的头部，只有 8 个字节，相对于 TCP 头部的 20 个字节信息包的额外开销很小。

限于篇幅，更多网络协议相关知识参考：

1. 如何快速入门网络基础知识（TCP/IP 和 HTTP）

2. 图解 HTTP

小结：必须熟练掌握 TCP 和 UDP 的区别、三次握手和四次挥手的状态切换，必考。




##数据库知识点



既然是后端开发，那么与数据库相关的知识点也是必不可少的。

01. MySQL 和 MongoDB 的区别有哪些？如何选择？

02. MongoDB 的优缺点有哪些？

（ps 本人对这一块不是很熟悉，就不附上参考答案了，请各位小伙伴自行学习哈~）

03. 听说过事务吗？（必考）

答：

作为单个逻辑工作单元执行的一系列操作，满足四大特性：

原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行；

一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态；

隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；

持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存。

04. 事务的并发问题有哪几种？

答：丢失更新、脏读、不可重复读以及幻读。

05. 数据库中的锁有哪几种？

答：独占锁、排他锁以及更新锁。

06. 事务的隔离级别有哪几种？

答：读未提交、读已提交、可重复读和序列化。

扩展问题：MySQL 事务默认隔离级别是哪个？

答：可重复读。

07. 数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？

答：

索引  是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；

底层数据结构是 B+ 树；

使用 B+ 树的原因：查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（ 此时，你应该在白纸上画出什么是 B+ 树 ）

扩展问题：聚簇索引和非聚簇索引的区别？

08. MyISAM 和 InnoDB 的区别有哪些？

答：

MyISAM 不支持事务，InnoDB 是事务类型的存储引擎；

MyISAM 只支持表级锁，BDB 支持页级锁和表级锁，默认为页级锁；而 InnoDB 支持行级锁和表级锁，默认为行级锁；

MyISAM 引擎不支持外键，InnoDB 支持外键；

MyISAM 引擎的表在大量高并发的读写下会经常出现表损坏的情况；

对于 count( ) 查询来说 MyISAM 更有优势；

InnoDB 是为处理巨大数据量时的最大性能设计，它的 CPU 效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的；

MyISAM 支持全文索引（FULLTEXT），InnoDB 不支持；

MyISAM 引擎的表的查询、更新、插入的效率要比 InnoDB 高。

最主要的区别是：MyISAM 表不支持事务、不支持行级锁、不支持外键。 InnoDB 表支持事务、支持行级锁、支持外键。（可直接回答这个）

09. 数据库中 Where、group by、having 关键字：

答：  

关键字作用：

where 子句用来筛选 from 子句中指定的操作所产生的的行；

group by 子句用来分组 where 子句的输出；

having 子句用来从分组的结果中筛选行；

having 和 where 的区别：

语法类似，where 搜索条件在进行分组操作之前应用；having 搜索条件在进行分组操作之后应用；

having 可以包含聚合函数 sum、avg、max 等；

having 子句限制的是组，而不是行。

当同时含有 where 子句、group by 子句 、having 子句及聚集函数时，执行顺序如下：

执行 where 子句查找符合条件的数据；

使用 group by 子句对数据进行分组；对 group by 子句形成的组运行聚集函数计算每一组的值；最后用 having 子句去掉不符合条件的组。

10. 还有一些问题，如 MySQL 和 SQL Server 用法上的区别、limit 关键字的使用等问题。

小结：数据库方面还是事务机制、隔离级别比较重要，当然了数据库索引是必考的问题。

偶尔也会给你几个表，让你现场写 SQL 语句，主要考察 group by 和 having 等关键字。




##框架相关知识



我在项目中使用的框架有 Spring MVC 和 MyBatis，所以在简历上只写了这两种框架，面试官主要针对这两种框架进行提问。以下问题供小伙伴们参考。

JavaWeb 开发经典的 3 层框架：Web 层、Service 层（业务逻辑层）和 Dao 层（数据访问层）

Web 层：包含 JSP 和 Servlet 等与 Web 相关的内容；

业务层：只关心业务逻辑；

数据层：封装了对数据库的访问细节。

Spring 知识点

快速学习 Spring Boot 技术栈

Spring / Spring Boot 原理与实践

01. Spring 的 IOC 和 AOP 有了解吗？

答：

IOC：控制反转，（解耦合）将对象间的依赖关系交给 Spring 容器，使用配置文件来创建所依赖的对象，由主动创建对象改为了被动方式；

AOP：面向切面编程，将功能代码从业务逻辑代码中分离出来。

02. AOP 的实现方式有哪几种？如何选择？（必考）

答：

JDK 动态代理实现和 cglib 实现。

选择：

如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP，也可以强制使用 cglib 实现 AOP；

如果目标对象没有实现接口，必须采用 cglib 库，Spring 会自动在 JDK 动态代理和 cglib 之间转换。

扩展：JDK 动态代理如何实现？（加分点）

答：

JDK 动态代理，只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。

原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。

定义一个实现接口 InvocationHandler 的类；

通过构造函数，注入被代理类；

实现 invoke（ Object proxy, Method method, Object[] args）方法；

在主函数中获得被代理类的类加载器；

使用 Proxy.newProxyInstance( ) 产生一个代理对象；

通过代理对象调用各种方法。

03. Spring MVC 的核心控制器是什么？消息处理流程有哪些？

答：

核心控制器为 DispatcherServlet。消息流程如下：



04. 其他问题包括：重定向和转发的区别、动态代理和静态代理的区别等。

Mybatis 知识点

关于 MyBatis 主要考察占位符#和 $ 的区别，区别如下：

符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号；
$ 符号将传入的数据直接显示生成 SQL 中；
符号存在预编译的过程，，对问号赋值，防止 SQL 注入；

$ 符号是直译的方式，一般用在 order by ${列名}语句中；

能用#号就不要用 $ 符号。

小结：限于作者水平，MVC 框架方面了解不是太多，实战能力欠缺。面试官偶尔问框架底层实现原理等都知之甚少，有能力的小伙伴可以多加学习。



点击图片 查看专题


##大数据相关知识



大数据相关是因为我的简历上写了 KafKa 相关项目，所以面试官会进行提问 KafKa 相关知识点，我也进行了一些简单概念总结，深层次的实现原理因为并没有特别多的实战经验，所以并不了解。

以下概念总结供小伙伴参考。

01. KafKa 基本特性：

答：

快速持久化、支持批量读写消息、支持消息分区，提高了并发能力、支持在线增加分区、支持为每个分区创建多个副本。

扩展：为什么可以实现快速持久化？

答：

KafKa 将消息保存在磁盘中，并且读写磁盘的方式是顺序读写，避免了随机读写磁盘（寻道时间过长）导致的性能瓶颈；磁盘的顺序读写速度超过内存随机读写。

【Kafka 入门与实践】

02. 核心概念

答：

生产者（Producer）： 生产消息，并且按照一定的规则推送到 Topic 的分区中。

消费者（Consumer）： 从 Topic 中拉去消息，并且进行消费。

主题（Topic）： 用于存储消息的逻辑概念，是一个消息集合。

分区（partition）：

每个 Topic 可以划分为多个分区，每个消息在分区中都会有一个唯一编号 offset

kafka 通过 offset 保证消息在分区中的顺序

同一 Topic 的不同分区可以分配在不同的 Broker 上

partition 以文件的形式存储在文件系统中。

副本（replica）：

KafKa 对消息进行了冗余备份，每个分区有多个副本，每个副本中包含的消息是 “一样” 的。

每个副本中都会选举出一个 Leader 副本，其余为 Follower 副本，Follower 副本仅仅将数据从 Leader 副本拉去到本地，然后同步到自己的 Log 中。

消费者组（Consumer Group）： 每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。

Broker：

一个单独的 server 就是一个 Broker；

主要工作：接收生产者发过来的消息，分配 offset，并且保存到磁盘中；

Cluster&Controller：

多个 Broker 可以组成一个 Cluster，每个集群选举一个 Broker 来作为 Controller，充当指挥中心

Controller 负责管理分区的状态，管理每个分区的副本状态，监听 ZooKeeper 中数据的变化等工作

保留策略和日志压缩：

不管消费者是否已经消费了消息，KafKa 都会一直保存这些消息（持久化到磁盘）；

通过保留策略，定时删除陈旧的消息；

日志压缩，只保留最新的 Key-Value 对。

关于副本机制：（加分点）

ISR 集合 ：表示当前 “可用” 且消息量与 Leader 相差不多的副本集合。满足条件如下：

副本所在节点必须维持着与 ZooKeeper 的连接；

副本最后一条信息的 offset 与 Leader 副本的最后一条消息的 offset 之间的差值不能超过指定的阈值。

深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列

HW&LEO：

HW 标记了一个特殊的 offset，当消费者处理消息的时候，只能拉取到 HW 之前的消息；

HW 也是由 Leader 副本管理的；

LEO（Log End Offset）是所有副本都会有的一个 offset 标记。

ISR、HW 和 LEO 的工作配合：

producer 向此分区中推送消息；

Leader 副本将消息追加到 Log 中，并且递增其 LEO；

Follower 副本从 Leader 副本中拉取消息进行同步；

Follower 副本将消息更新到本地 Log 中，并且递增其 LEO；

当 ISR 集合中的所有副本都完成了对 offset 的消息同步，Leader 副本会递增其 HW

KafKa 的容灾机制：通过分区的副本 Leader 副本和 Follower 副本来提高容灾能力。

小结：请小伙伴根据自己的简历自行准备学习大数据相关知识点。




##Linux 常见命令



作者对这一方面不是很精通，知识点来源于网络总结以及面试官的提问，仅供小伙伴参考。

01. grep、sed 以及 awk 命令

解析：awk 命令如果可以掌握，是面试中的一个  加分点。

02. 文件和目录：

pwd 显示当前目录

ls 显示当前目录下的文件和目录：

ls -F 可以区分文件和目录；

ls -a 可以把隐藏文件和普通文件一起显示出来；

ls -R 可以递归显示子目录中的文件和目录；

ls -l 显示长列表；

ls -l test 过滤器，查看某个特定文件信息。可以只查看 test 文件的信息。

03. 处理文件方面的命令有：touch、cp、 In、mv、rm、          

04. 处理目录方面的命令：mkdir

05. 查看文件内容：file、cat、more、less、tail、head

06. 监测程序命令：ps、top

eg. 找出进程名中包括 java 的所有进程：ps -ef | grep java

top 命令 实时监测进程

top 命令输出的第一部分：显示系统的概括。

第一行显示了当前时间、系统的运行时间、登录的用户数和系统的平均负载（平均负载有 3 个值：最近 1min 5min 15min）；

第二行显示了进程的概要信息，有多少进程处于运行、休眠、停止或者僵化状态；

第三行是 CPU 的概要信息；

第四行是系统内存的状态。

07. ps 和 top 命令的区别：

ps 看到的是命令执行瞬间的进程信息 , 而 top 可以持续的监视；

ps 只是查看进程 , 而 top 还可以监视系统性能 , 如平均负载 ,cpu 和内存的消耗；

另外 top 还可以操作进程 , 如改变优先级 (命令 r) 和关闭进程 (命令 k)；

ps 主要是查看进程的，关注点在于查看需要查看的进程；

top 主要看 cpu, 内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况。

08. 压缩数据

tar -xvf 文件名；

tar -zxvf 文件名；

tar -cvzf 文件名。

09. 结束进程：kill PID 或者 kill all

结束语